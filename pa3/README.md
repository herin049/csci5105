# System Design

For this programming project, the functionality of the system is made up of three major entities: the client, the server and the coordinator.

The system is implemented in Python and makes use of the [Apache Thrift](https://thrift.apache.org/) RPC library for communication between nodes in the system. The source for the client can be found in the `client.py` and `client_interactive.py` files. Likewise, the source for the server/coordinator nodes can be found in the `server.py` file. The Thrift object for the system are defined in the `service.thrift` file. 

The goal of this project is to build a simple distributed file system capable of sharing several files between multiple clients replicated to several servers to increased performance and reliability. In order to achieve this goal, Gifford's Quorum-Based Protocol will be used to ensure that read and write operations to the same file are serialized in order to achieve sequential consistency. If we let N<sub>r</sub> and N<sub>w</sub> denote the size of each read and write quorum in the system (i.e. how many servers must a client receive approval from before performing a read or write operation), then if N is the total number of nodes in the system, Gifford's Quorum-Based Protocol requires that

1. N<sub>r</sub> + N<sub>w</sub> > N
2. N<sub>w</sub> > N / 2

The first requirement ensures that there are no read-write conflicts. Furthermore, it also ensures that at least one node in any read quorum contains the most up-to-date version of a given object. Likewise, the second requirement ensures that there are no write-write conflicts. With Gifford's Quorum-Based Protocol, the system can be implemented by first forming a collection of N servers and designating one of these servers to the coordinator. When a client wishes to perform a read/write operation, it will then be able to contact an arbitrary server which will forward its request to the coordinator. From here, the coordinator will form a read/write quorum to successfully perform the operation and return the result back to the client. 


The implementation for a server which is not designated as a coordinator is very straightfroward since most of the logic for Gifford's Quorum-Based Protocol is handled by the coordinator. Each server implements the `ServerService` Thrift service which exposes functions for the client for reading, writing and listing files in the system as well as function for the coordinator for updating, reading and retrieving versions for different files. When a regular server node recieves a request to read, write or list files in the system, it simply forwards the request to the coordinator server. Internally, each server contains a table which contains all the files and their associated versions that are currently located on the given server. When a server receives a request from the coordinator to retrieve all of the files on the server and their versions, the server simply returns every file and its version present in its file version table. Getting the content for the current version of a file is also very simple and simply involves reading the file in the server's storage path and sending back the content to the coordinator. Likewise, updating the content and version for a file simply involves writing the new content provided to the associated file and incrementing the version number. 

The implementation for the coordinator server is slightly more complicated and involves ensuring the Gifford's Quorum-Based Protocol is followed correctly. Because each coordinator is also a regular server, the coordinator also has a server handler which handles all requests made through the `ServerService` interface. Each coordinator also implements the `CoordinatorService` Thrift service which exposes functions to the other servers for reading, writing and listing files in the system. The coordinator server internally has a table containing a lock for each file in the system. When the coordinator receives a request to read from a file, it first acquires the corresponding lock for the file. Next, it forms a read quourum with size N<sub>r</sub> which is specified in the configuration file. It then contacts all of the servers in this write quorum and retrieves the contents of the file from the server with the highest version number, forwaring the result back to the caller. Finally, it releases the lock for the file so that other operations can be performed on this file. Handling a write request is analogous to handling a read request with the exception that the coordinator first finds the server with the highest version number and increments it by one. Then, it makes a request to each server in the write quourum to update the version and content of the file accordingly. Hnadling a request to retrieve all the file and their associated versions is slightly different. First, the coordinator acquires the file table lock to ensure that no new files are created or modified while retrieving all the files in the system. Next, the coordinator forms a read quorum and contacts each server requesting all of its files and associated versions. The coordinator then returns a list of all files returned from the servers in the read quorum with the version number for each file being the maximum version number for the given file. 
